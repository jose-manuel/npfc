#!/usr/bin/env python

"""
Script nfn_extract_edges
==========================

"""

# standard lib
from pathlib import Path
import pickle
import base64
# data handling
import json
import numpy as np
import pandas as pd
from collections import Counter
# chemoinformatics
import rdkit
from rdkit import Chem
from rdkit.Chem import AllChem
# dev library
import npfc
from npfc import load
from npfc import draw
import matplotlib.pyplot as plt  # required for creating a canvas for displaying graphs
from matplotlib.figure import Figure
from networkx.classes.graph import Graph
# display molecules
from rdkit.Chem import Draw
from rdkit.Chem.Draw import rdMolDraw2D
from rdkit.Chem.Draw import IPythonConsole
from rdkit.Chem import PandasTools
from IPython.display import SVG
import networkx as nx


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #


def compute_score(x, y):
    if y > 0:
        return (x / y) * 100
    return -1.0  # for easy tell on barplot what combinations are not annotated


def format_edges(df_edges, categories):
    ds_edge_counts = []

    # fragment pairs
    fragment_pairs = df_edges.groupby(['source','target'])
    for fpid, fp in fragment_pairs:

        # init dict for this pair
        d_edge_counts = {}
        d_edge_counts.update({f"n_fc_{cat}": 0.0 for cat in categories})
        d_edge_counts.update({f"n_active_{cat}": 0.0 for cat in categories})
        d_edge_counts.update({f"n_tot_{cat}": 0.0 for cat in categories})
        d_edge_counts["source"] = fpid[0]
        d_edge_counts["target"] = fpid[1]
        d_edge_counts['idm'] = '|'.join([str(x) for x in list(fp['idm'].unique())])

        # iterate over each combination of fragments: f1-[fcc]-f2
        groups = df_edges.groupby(["source", "target", "abbrev"])
        for gid, group in groups:

            # define whqt type of comb we are investigating
            fcc = gid[2]
            d_edge_counts["fcc"] = fcc

            # fill dict with counts
            d_edge_counts[f"n_fc_{fcc}"] = len(group)
            n_active = group['n_active'].sum()
            n_tot = group['n_tot'].sum()
            d_edge_counts[f"n_active_{fcc}"] = n_active
            d_edge_counts[f"n_tot_{fcc}"] = n_tot

        # record dict
        ds_edge_counts.append(d_edge_counts)

    # assemble df and convert col types
    df_edges_fc = pd.DataFrame(ds_edge_counts)
    for c in df_edges_fc.columns:
        if 'n_' in c:
            df_edges_fc[c] = df_edges_fc[c].astype(float)
    # reorder cols
    cols = ['source', 'target', 'idm'] + [f"n_fc_{c}" for c in categories] + [f"n_active_{c}" for c in categories] + [f"n_tot_{c}" for c in categories]
    df_edges_fc = df_edges_fc[cols]

    return df_edges_fc


def score_pnp(idms, df_pnps):
    # idms: list of idms
    # df_pnps: df which is basically a list of pnp mols
    # if idm is found in df_pnps, add +1 to pnp_count.
    count_pnp = 0
    count_tot = 0
    for idm in idms:
        if any(df_pnps['idm'].isin([idm])):
            count_pnp += 1
        count_tot += 1
    return (count_pnp/count_tot) * 100


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MAIN ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #


if __name__ == '__main__':

    d0 = datetime.now()

    parser = argparse.ArgumentParser(description="Compute all required files for analyzing FCC results", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('input_pnp', type=str, default=None, help="")
    parser.add_argument('input_dir_png_fragments', default=None, type=str, default=None, help="")
    parser.add_argument('output_nfn', type=str, default=None, help="")
    parser.add_argument('--log', type=str, default='INFO', help="Specify level of logging. Possible values are: CRITICAL, ERROR, WARNING, INFO, DEBUG.")
    args = parser.parse_args()


    # logging
    logger = utils._configure_logger(args.log)
    logger.info("RUNNING NFN_EXTRACT_EDGES")
    warnings.filterwarnings('ignore', category=pd.io.pytables.PerformanceWarning)  # if None is returned instead of a molecule, do not complain about mixed types
    pd.options.mode.chained_assignment = None  # disable pd.io.pytables.SettingWithCopyWarning
    pad = 40
    lg = RDLogger.logger()
    lg.setLevel(RDLogger.INFO)

    logger.info("LIBRARY VERSIONS:")
    logger.info("rdkit".ljust(pad) + f"{rdkit.__version__}")
    logger.info("pandas".ljust(pad) + f"{pd.__version__}")
    logger.info("npfc".ljust(pad) + f"{npfc.__version__}")

    # parameters

    # i/o
    utils.check_arg_input_file(args.input_pnp)
    utils.check_arg_input_dir(args.input_dir_png_fragments)
    utils.check_arg_output_file(args.output_nfn)

    # formats
    input_pnp_format, input_pnp_compression = utils.get_file_format(args.input_pnp)
    output_nfn_format, output_nfn_compression = utils.get_file_format(args.output_nfn)
