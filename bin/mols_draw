#!/usr/bin/env python

"""
Script mols_draw
==========================
This script is used for generating drawings of molecules.
"""

# standard
import warnings
import sys
from datetime import datetime
import logging
import pandas as pd
import argparse
import re
from PIL import Image
from PIL import ImageOps
from PIL import ImageDraw
import numpy as np
# chemoinformatics
import rdkit
from rdkit.Chem import Draw
# dev
import npfc
from npfc import load
from npfc import utils


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #


def main():

    # init
    description = """Script used drawing individual SVG files for each molecule.

    It uses the installed npfc libary in your favorite env manager.

    Example:

        >>> mols_draw input_file.csv.gz output_dir

    """
    ds = [('START', datetime.now())]
    # parameters CLI
    parser = argparse.ArgumentParser(description=description, formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('input_file', type=str, default=None, help="Input file. Molecules to display are in column 'mol'. If a _colormap column is also avaialble, molecules are highlighted.")
    parser.add_argument('output_dir', type=str, default=None, help="Output directory where to save SVG files.")
    parser.add_argument('-s', '--size', type=str, default='(400,400)', help="Size allocated for each subimage.")
    parser.add_argument('-f', '--format', type=str, default='PNG', help="Either PNG or SVG. PNG only is supported with Cytoscape.")
    parser.add_argument('-r', '--round', type=bool, default=True, help="For PNG only, round the image so it becomes circular.")
    parser.add_argument('--log', type=str, default='INFO', help="Specify level of logging. Possible values are: CRITICAL, ERROR, WARNING, INFO, DEBUG.")
    args = parser.parse_args()

    # logging
    logger = utils._configure_logger(args.log)
    logger.info("RUNNING FRAGMENT MAPPING")
    warnings.filterwarnings('ignore', category=pd.io.pytables.PerformanceWarning)  # if None is returned instead of a molecule, do not complain about mixed types
    pad = 40

    # parse arguments
    utils.check_arg_input_file(args.input_file)
    utils.check_arg_output_dir(args.output_dir)

    # size
    pattern = re.compile(r'\([0-9]+,[0-9]+\)')
    size = args.size.replace(' ', '')
    if not pattern.match(size):
        raise ValueError(f"ERROR! EXPECTED SYNTAX '(xxx,xxx)' FOR SIZE ARGUMENT BUT GOT '({size})' INSTEAD!")
    size = size.replace('(', '').replace(')', '')
    input_format, input_compression = utils.get_file_format(args.input_file)
    size = tuple([int(x) for x in size.split(',')])

    # format
    format = args.format.upper()
    if format not in ('PNG', 'SVG'):
        raise ValueError(f"ERROR! EXPECTED FORMAT IS EITHER SVG OR PNG BUT GOT '({format})' INSTEAD!")
    if format == 'PNG':
        use_svg = False
    else:
        use_svg = True

    # display infos
    logger.info("LIBRARY VERSIONS:")
    logger.info("rdkit".ljust(pad) + f"{rdkit.__version__}")
    logger.info("pandas".ljust(pad) + f"{pd.__version__}")
    logger.info("npfc".ljust(pad) + f"{npfc.__version__}")
    logger.info("ARGUMENTS:")
    logging.info("INPUT_FILE".ljust(pad) + f"{args.input_file}")
    logging.info("INPUT_FORMAT".ljust(pad) + f"{input_format}")
    logging.info("INPUT_COMPRESSION".ljust(pad) + f"{input_compression}")
    logging.info("OUTPUT_DIR".ljust(pad) + f"{args.output_dir}")
    logging.info("SIZE".ljust(pad) + f"{size}")
    logging.info("FORMAT".ljust(pad) + f"{format}")
    if format == 'PNG':
        logging.info("ROUND".ljust(pad) + f"{args.round}")
    logging.info("LOG".ljust(pad) + f"{args.log}")

    # begin
    logging.info("BEGIN")
    ds.append(('START', datetime.now()))

    # load input_file
    logging.info("LOADING INPUT FILE")
    df = load.file(args.input_file)
    if 'mol' not in df.columns:
        logger.error(f"ERROR! COLUMN 'mol' NOT FOUND IN INPUT FILE, ABORTING!")
        sys.exit(1)
    nentries = len(df.index)
    df = df.groupby('idm').first().reset_index()
    logging.info(f"FOUND {nentries:,d} MOLS IN {len(df.index):,d} ENTRIES")
    ds.append(('LOADING INPUT FILE', datetime.now()))

    # compute images
    logger.info(f"GENERATING DRAWINGS")
    for i in range(len(df.index)):
        row = df.iloc[i]
        img = Draw.MolsToGridImage([row['mol']],
                                   molsPerRow=1,
                                   subImgSize=size,
                                   useSVG=use_svg,
                                   )
        if format == 'SVG':
            output_svg = f"{args.output_dir}/{row['idm']}.svg"
            with open(output_svg, "w") as FILE:
                FILE.write(img)
        else:
            output_png = f"{args.output_dir}/{row['idm']}.png"
            if args.round:
                # following procedure described at: https://stackoverflow.com/questions/51486297/cropping-an-image-in-a-circular-way-using-python
                img = img.convert("RGB")
                npImage = np.array(img)
                h, w = img.size

                # Create same size alpha layer with circle
                alpha = Image.new('L', img.size, 0)
                draw = ImageDraw.Draw(alpha)
                draw.pieslice([0, 0, h, w], 0, 360, fill=255)

                # Convert alpha Image to numpy array
                npAlpha = np.array(alpha)

                # Add alpha layer to RGB
                npImage = np.dstack((npImage, npAlpha))

                # Save with alpha
                img = Image.fromarray(npImage)

            img.save(output_png)
    ds.append(('GENERATING DRAWINGS', datetime.now()))

    # end
    ds.append((f"END", datetime.now()))
    logging.info("SUMMARY")
    for i in range(len(ds) - 1):
        if ds[i+1] != 'END':
            logger.info(f"COMPUTATIONAL TIME: {ds[i+1][0]}".ljust(pad * 2) + f"{ds[i+1][1] - ds[i][1]}")
    logger.info("COMPUTATIONAL TIME: TOTAL".ljust(pad * 2) + f"{ds[-1][1] - ds[0][1]}")
    logging.info("END")


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MAIN ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #


if __name__ == '__main__':
    main()
    sys.exit(0)
