#!/usr/bin/env python

"""
Script fct_fragment
==========================
This script generates the fragment table file. This table consists in informations
about fragments that are not part of the molecule table, such as the fragment combination
point labels and the number of symmetry centers in the fragments.
"""
import argparse
from datetime import datetime
import sys
import json
# data
import pandas as pd
# chemoinformatics
import rdkit
# dev
import npfc
from npfc import load
from npfc import save
from npfc import utils


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

def main():

    # init
    d0 = datetime.now()
    description = """Script for generating the fragment node table for a given input file (or chunk).
    The output fragment contains:
        - the fragment_id (identical to the molecule_id)
        - the fragment combination point labels
        - the number of symmetry centers

    Example:

        >>> fct_fragment dataset/05_depict/data/file.csv.gz fragment.csv.gz

    """

    # parameters CLI
    parser = argparse.ArgumentParser(description=description, formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('input_latest_step', type=str, default=None, help="Output file from the load step.")
    parser.add_argument('output_table', type=str, default=None, help="Output file with annotated molecules.")
    parser.add_argument('--log', type=str, default='INFO', help="Specify level of logging. Possible values are: CRITICAL, ERROR, WARNING, INFO, DEBUG.")
    args = parser.parse_args()

    # logging
    logger = utils._configure_logger(args.log)
    logger.info("RUNNING FCT_FRAGMENT")
    pad = 40

    # parse arguments
    utils.check_arg_input_file(args.input_latest_step)
    utils.check_arg_output_file(args.output_table)

    # display informations

    # versions
    logger.info("LIBRARY VERSIONS:")
    logger.info("rdkit".ljust(pad) + f"{rdkit.__version__}")
    logger.info("pandas".ljust(pad) + f"{pd.__version__}")
    logger.info("npfc".ljust(pad) + f"{npfc.__version__}")
    # arguments
    logger.info("ARGUMENTS:")
    logger.info("INPUT_LATEST_STEP".ljust(pad) + f"{args.input_latest_step}")
    logger.info("OUTPUT_MOLECULE_TABLE".ljust(pad) + f"{args.output_table}")
    # log
    logger.info("LOG".ljust(pad) + f"{args.log}")

    # begin

    logger.info("BEGIN")
    d1 = datetime.now()

    # load input
    logger.info("LOADING INPUT FILE")
    df = load.file(args.input_latest_step)[['idm', '_fcp_labels', 'num_symmetry_groups']].rename({'idm': 'fragment_id', '_fcp_labels': 'fragment_combination_points'}, axis=1)
    d2 = datetime.now()

    # process data
    logger.info("PROCESSING DATA")
    df['fragment_combination_points'] = df['fragment_combination_points'].map(lambda x: json.dumps(x).replace('"', '').replace('{', '').replace('}', ''))
    df = df[['fragment_id', 'num_symmetry_groups', 'fragment_combination_points']]
    d3 = datetime.now()

    # save file
    logger.info("SAVING OUTPUT")
    save.file(df, args.output_table)
    d4 = datetime.now()

    # end

    logger.info("SUMMARY")
    logger.info("COMPUTATIONAL TIME: CONFIGURING JOB".ljust(pad * 2) + f"{d1-d0}")
    logger.info("COMPUTATIONAL TIME: LOADING INPUT".ljust(pad * 2) + f"{d2-d1}")
    logger.info("COMPUTATIONAL TIME: PROCESSING DATA".ljust(pad * 2) + f"{d3-d2}")
    logger.info("COMPUTATIONAL TIME: SAVING OUTPUT".ljust(pad * 2) + f"{d4-d3}")
    logger.info("COMPUTATIONAL TIME: TOTAL".ljust(pad * 2) + f"{d4-d0}")
    logger.info("END")
    sys.exit(0)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MAIN ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #


if __name__ == '__main__':
    main()
    sys.exit(0)
