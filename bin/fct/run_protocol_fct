#!/usr/bin/env python

"""
Script fct_run_protocol
==========================
This script is used for running a Fragment Combination Tree (FCT) protocol.
"""

# standard
from datetime import datetime
import logging
from pathlib import Path
import re
import sys
import subprocess
import warnings
import argparse
import pkg_resources
# data handling
import json
import pandas as pd
# chemoinformatics
import rdkit
# dev
import npfc
from npfc import utils


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #


def main():
    # init
    ds = []
    ds.append(('START', datetime.now()))
    description = """This script is used for running a NPFC Fragment Combination Tree (FCT) protocol,
    using Snakemake locally or in a cluster environment.

    3 protocols are setup by default: 'fragments', 'natural', 'synthetic'.

    These keywords actually refer to hard-coded snakefiles addressing tasks of this project.

    If you would like to run another snakefile, you just have to provide a file. On par with the snakefile, one needs to provide
    a configuration file in JSON format with the expected parameters. Any parameter found in that file will be transferred to the snakefile, which
    is particularly useful for avoiding hard-coded paths, etc. and make the snakefiles more reusable.

    This script uses the installed npfc libary in your favorite env manager.

    """
    # parameters CLI
    parser = argparse.ArgumentParser(description=description, formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('protocol', type=str, default=None, help="Protocol to apply. If this is not a file, then a lookup for matching the string with known protocols is performed. Possible values are: fragments/natural/synthetic.")
    parser.add_argument('-e', '--env', type=str, default='local', help="Environment for running the protocol. By default locally, but it can also be run on cluster schedulers (clem/gwdg1).")
    parser.add_argument('-j', '--jobs', type=int, default=6, help="Number of jobs that can be run simultaneously when workflow is run locally.")
    parser.add_argument('-c', '--config', type=str, default=None, help="JSON configuration file for setting up default variables when the running the protocol. Arguments below overwrite parameters specified in the config file.")
    parser.add_argument('-w', '--wd', type=str, default=None, help="Working directory containing the data folder, where output subfolders and files are stored.")
    parser.add_argument('--log', type=str, default='INFO', help="Specify level of logging. Possible values are: CRITICAL, ERROR, WARNING, INFO, DEBUG.")
    args = parser.parse_args()

    # logging
    logger = utils._configure_logger(args.log)
    pad = 40
    warnings.filterwarnings('ignore', category=pd.io.pytables.PerformanceWarning)  # if None is returned instead of a molecule, do not complain about mixed types
    logger.info("RUNNING NPFC FCT PROTOCOL")

    # parse arguments
    errors = []
    # protocol
    if args.protocol not in ('fragments', 'natural', 'synthetic', 'commercial') and not Path(args.protocol).exists():
        errors.append(f"ERROR! UNKNOWN PROTOCOL ({args.protocol})!")  # error if file does not exist or if protocol is not recorded as package data

    # config
    if args.config is not None:
        if not Path(args.config).exists():
            errors.append(f"ERROR! CONFIG FILE FOR PROTOCOL '{args.protocol}' COULD NOT BE FOUND AT '{args.config}'!")

    # display general infos
    logger.info("LIBRARY VERSIONS".center(pad))
    logger.info("rdkit".ljust(pad) + f"{rdkit.__version__}")
    logger.info("pandas".ljust(pad) + f"{pd.__version__}")
    logger.info("npfc".ljust(pad) + f"{npfc.__version__}")
    logger.info("ARGUMENTS".center(pad))
    logger.info("PROTOCOL".ljust(pad) + f"{args.protocol}")
    logger.info("CONFIG".ljust(pad) + f"{args.config}")
    logger.info("ENV".ljust(pad) + f"{args.env}")
    logger.info("JOBS".ljust(pad) + f"{args.jobs}")

    # default keys set to None
    config = ['frags_subdir', 'natref_subdir',
              'root_dir', 'prep_subdir', 'prefix',
              ]
    config = {k: None for k in config}

    # begin
    ds.append(('CONFIGURE', datetime.now()))
    logger.info("BEGIN")

    # configure job by updating config with config_parsed
    if args.config is not None:
        config_file = args.config
        logger.info("PARSING SPECIFIED CONFIG FILE")
    else:
        config_file = pkg_resources.resource_filename('npfc', f"data/{args.protocol}.json")
        logger.info(f"NO SPECIFIED CONFIG FILE, PARSING DEFAULT CONFIG FILE AT '{config_file}'")
    with open(config_file, 'r') as CONFIG:
        config_parsed = json.load(CONFIG)
    config.update(config_parsed)
    logger.info("OPTIONS IN CONFIGURATION FILE:")
    [logger.info(f"OPTION {opt}".ljust(pad) + f"{value}") for opt, value in config.items()]

    # check arguments

    # wd
    if args.wd is not None:
        logger.info(f"OVERWRITING WD TO {args.wd}")
        config['WD'] = args.wd
    if not utils.check_arg_input_dir(config['WD']):
        errors.append(f"ERROR! WD COULD NOT BE FOUND AT '{config['WD']}'!")

    # env
    if args.env not in ('local', 'gwdg1', 'clem'):
        errors.append(f"ERROR! UNKNOWN ENV ({args.env})!")

    # jobs
    if args.jobs < 1:
        errors.append(f"ERROR! UNSUITABLE VALUE FOR JOBS ({args.jobs})")

    # exit on error(s)
    n_errors = len(errors)
    if n_errors > 0:
        logger.error(f"{n_errors} ERROR(S) FOUND DURING ARGUMENT PARSING:\n" + '\n'.join(errors) + "\n")
        sys.exit(1)

    logger.info(f"PROTOCOL - {args.protocol}".center(pad))
    # automatically retrieve all variables and append them to command string using key=value
    if Path(args.protocol).is_file():
        smk_file = args.protocol
    else:
        try:
            smk_file = pkg_resources.resource_filename('npfc', f"data/fct/fct_{args.protocol}.smk")
        except ValueError:   # ### no tested
            logger.error(f"ERROR! PROTOCOL '{args.protocol}' COULD NOT BE FOUND EITHER IN STORED PROTOCOLS OR AT LOCATED FILE!")
    # configure current smk command
    smk_command = f"snakemake -k -s {smk_file} --jobname fct_{args.protocol}" + "_{rulename}.{jobid} "

    # determine environment
    if args.env == 'local':
        smk_command += f"-j {args.jobs} "
    elif args.env == 'clem':
        config_cluster = pkg_resources.resource_filename('npfc', "data/cluster_clem.json")
        smk_command += '-j 100 --cluster-config ' + config_cluster + ' --cluster "sbatch -A {cluster.account} -p {cluster.partition} -n {cluster.n}  -t {cluster.time} --oversubscribe" '
    elif args.env == 'gwdg1':
        smk_command = "sbatch -p medium -t '12:00:00'" + smk_command
        config_cluster = pkg_resources.resource_filename('npfc', "data/cluster_gwdg1.json")
        smk_command += '-j 400 --cluster-config ' + config_cluster + ' --cluster "sbatch -p medium -n {cluster.n}  -t {cluster.time} --oversubscribe" '

    # arguments
    if 'fragments' in args.protocol:
        protocol = 'fragments'
    elif 'natural' in args.protocol:
        protocol = 'natural'
    elif 'synthetic' in args.protocol:
        protocol = 'synthetic'
    elif 'commercial' in args.protocol:
        protocol = 'commercial'
    elif 'other' in args.protocol:
        protocol = 'other'
    else:
        raise ValueError(f"UNKNOWN PROTOCOL! ('{args.protocol}')")

    # count the number of chunks for natural and synthetic
    if protocol != 'fragments':
        num_chunks = len([str(Path(x).stem) for x in list(Path(config['root_dir']).glob(f"data/{config['prep_subdir']}/02_load/data/*.csv.gz"))])
        config['num_chunks'] = num_chunks

    # add arguments to the smk command
    smk_command += "--config "
    for k, v in config.items():
        if v is not None:
            logger.info(f"OPT {k}".ljust(pad) + f"{v}")
            smk_command += f"{k}='{v}' "
    smk_command = smk_command[:-1]

    logger.info(f"SMK COMMAND:\n{smk_command}\n")

    # draw the protocol task tree
    WD = config['WD']
    if WD.endswith('/'):
        WD = WD[:-1]

    svg = f"{WD}/{Path(args.config).stem}_tasktree.svg"
    smk_command_svg = smk_command + f" --rulegraph | dot -Tsvg > {svg}"
    logger.info(f"DRAWING TASK TREE AT '{svg}'")
    subprocess.run(smk_command_svg, shell=True, check=True)

    # run protocol
    logger.info("BEGIN OF SNAKEMAKE PROTOCOL")
    subprocess.run(smk_command, shell=True, check=True)
    ds.append((f"PROTOCOL '{args.protocol}'", datetime.now()))
    logger.info(f"END OF SNAKEMAKE PROTOCOL '{args.protocol}'")

    # end
    ds.append(("END", datetime.now()))
    logger.info("SUMMARY")
    for i in range(len(ds) - 1):
        if ds[i+1] != 'END':
            logger.info(f"COMPUTATIONAL TIME: {ds[i+1][0]}".ljust(pad * 2) + f"{ds[i+1][1] - ds[i][1]}")
    logger.info("COMPUTATIONAL TIME: TOTAL".ljust(pad * 2) + f"{ds[-1][1] - ds[0][1]}")
    logger.info("END")


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MAIN ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #


if __name__ == '__main__':
    main()
    sys.exit(0)
