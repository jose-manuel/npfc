#!/usr/bin/env python

"""
Script network_frags
==========================
This script is used for generating the Natural Fragment Network (NFN) edges file by combining nx Graph objects.
The output file can then be imported to Cytoscape.
"""

# standard
import warnings
import sys
from datetime import datetime
import logging
import pandas as pd
import argparse
from pathlib import Path
# chemoinformatics
import rdkit
# dev
import npfc
from npfc import load
from npfc import save
from npfc import utils
from npfc import fragment
# disable SettingWithCopyWarning warnings
pd.options.mode.chained_assignment = None  # default='warn'


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #


##### building this in jupyternb

def get_simple_edges(df_map):
    edges = []

    for i in range(len(df_map.index)):

        row = df_map.iloc[i]
        map_str = row["map_str"]
        for conn in map_str.split("-"):
            edges.append([conn.split(":")[0],  # fid1
                          conn.split("]")[1].split(":")[0],  # fid2
                          conn.split("[")[1].split("]")[0],  # label
                          row["idm"],  # idm
                          row["fmid"],  # fmid
                         ])


    df = pd.DataFrame(edges, columns=["fid1", "fid2", "label", "idm", "fmid"])
    df['weight'] = df.groupby(["fid1", "fid2", "label"])['label'].transform('count')
    df.drop_duplicates(subset=["fid1", "fid2", "label"], keep="first", inplace=True)
    return df

def main():

    # init
    d0 = datetime.now()
    description = """Script used for mapping fragment combinations.

    It uses the installed npfc libary in your favorite env manager.

    Example:

        >>> network_frags input_dir_maps output_file_nfn

    For parsing input files in input_dir, it takes example on first file read in folder for parsing options (file type and compression).

    """

    # parameters CLI
    parser = argparse.ArgumentParser(description=description, formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('input_dir', type=str, default=None, help="Input dir for fragment maps.")
    parser.add_argument('output_nfn', type=str, default=None, help="Output file ")
    parser.add_argument('--log', type=str, default='INFO', help="Specify level of logging. Possible values are: CRITICAL, ERROR, WARNING, INFO, DEBUG.")
    args = parser.parse_args()

    # logging
    logger = utils._configure_logger(args.log)
    logger.info("RUNNING FRAGMENT NETWORKING")
    warnings.filterwarnings('ignore', category=pd.io.pytables.PerformanceWarning)  # if None is returned instead of a molecule, do not complain about mixed types
    pad = 40

    # parse arguments
    utils.check_arg_input_dir(args.input_dir)
    utils.check_arg_output_file(args.output_nfn)
    chunks_map = [str(x) for x in list(Path(args.input_dir).glob("*"))]
    chunks_map.sort()   # in place
    map_format, map_compression = utils.get_file_format(chunks_map[0])  # take example on first file read
    # temp limitation
    if map_format != "CSV":
        raise ValueError(f"ERROR! FOR NOW ONLY CSV FILES WITH SEP='|' ARE ALLOWED! {map_format}")

    # display infos
    logger.info("LIBRARY VERSIONS:")
    logger.info("rdkit".ljust(pad) + f"{rdkit.__version__}")
    logger.info("pandas".ljust(pad) + f"{pd.__version__}")
    logger.info("npfc".ljust(pad) + f"{npfc.__version__}")
    logger.info("ARGUMENTS:")
    logging.info("INPUT_DIR".ljust(pad) + f"{args.input_dir}")
    logging.info("NUMBEF OF INPUT MAPS".ljust(pad) + f"{len(chunks_map)}")
    logging.info("MAP_FORMAT".ljust(pad) + f"{map_format}")
    logging.info("MAP_COMPRESSION".ljust(pad) + f"{map_compression}")
    logging.info("OUTPUT_NFN".ljust(pad) + f"{args.output_nfn}")
    logging.info("LOG".ljust(pad) + f"{args.log}")

    # parse map files
    logging.info("PARSING INPUT MAPS")
    df_map = pd.concat([load.file(x) for x in chunks_map])

    # compute the nfn edges


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MAIN ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #


if __name__ == '__main__':
    main()
    sys.exit(0)
